"""
Trading Bot Execution Engine with Agent Heartbeat System
"""

import asyncio
import logging
import traceback
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
import os

# Supabase client
try:
    from supabase import create_client, Client
    HAS_SUPABASE = True
except ImportError:
    HAS_SUPABASE = False
    # Define a placeholder type for type hints when supabase is not available
    from typing import Any as Client

from trading_bot.base_agent import BaseAgent


class HeartbeatManager:
    """Manages agent heartbeats and writes to Supabase"""
    
    def __init__(self, supabase_url: Optional[str] = None, supabase_key: Optional[str] = None):
        self.logger = logging.getLogger(__name__)
        self.supabase: Optional[Client] = None
        
        # Initialize Supabase client if credentials are available
        if HAS_SUPABASE and supabase_url and supabase_key:
            try:
                self.supabase = create_client(supabase_url, supabase_key)
                self.logger.info("✅ Supabase client initialized")
            except Exception as e:
                self.logger.error(f"❌ Failed to initialize Supabase client: {e}")
        else:
            if not HAS_SUPABASE:
                self.logger.warning("⚠️  Supabase package not available - heartbeats will be logged only")
            else:
                self.logger.warning("⚠️  Supabase credentials not provided - heartbeats will be logged only")
    
    async def heartbeat(self, agent_name: str, status: str = "healthy", last_error: Optional[str] = None, metadata: Optional[Dict] = None) -> bool:
        """
        Record agent heartbeat
        
        Args:
            agent_name: Name of the agent
            status: Agent status ('healthy', 'error', 'warning')
            last_error: Error message if any
            metadata: Additional metadata
            
        Returns:
            True if heartbeat was recorded successfully
        """
        timestamp = datetime.utcnow()
        
        # Always log the heartbeat
        if status == "healthy":
            self.logger.info(f"💓 {agent_name} heartbeat: {status}")
        elif status == "warning":
            self.logger.warning(f"⚠️  {agent_name} heartbeat: {status} - {last_error}")
        else:
            self.logger.error(f"❌ {agent_name} heartbeat: {status} - {last_error}")
        
        # Write to Supabase if available
        if self.supabase:
            try:
                data = {
                    "agent_name": agent_name,
                    "timestamp": timestamp.isoformat(),
                    "status": status,
                    "last_error": last_error,
                    "metadata": metadata or {}
                }
                
                result = self.supabase.table("trading_agent_heartbeats").insert(data).execute()
                self.logger.debug(f"📝 Heartbeat stored in Supabase for {agent_name}")
                return True
                
            except Exception as e:
                self.logger.error(f"❌ Failed to store heartbeat in Supabase: {e}")
                return False
        
        return True  # Still consider successful if logged locally


class AgentExecutor:
    """Executes agents with heartbeat monitoring and exception handling"""
    
    def __init__(self, heartbeat_manager: HeartbeatManager):
        self.heartbeat_manager = heartbeat_manager
        self.logger = logging.getLogger(__name__)
        
    async def execute_agent_with_heartbeat(self, agent: BaseAgent, snapshot: Dict[str, Any]) -> List[Dict]:
        """
        Execute agent's generate_signals with heartbeat monitoring
        
        Args:
            agent: The trading agent to execute
            snapshot: Market data snapshot
            
        Returns:
            List of signals generated by the agent
        """
        agent_name = agent.name
        signals = []
        last_error = None
        status = "healthy"
        
        try:
            # Record heartbeat before execution
            await self.heartbeat_manager.heartbeat(
                agent_name=agent_name,
                status="healthy",
                metadata={"execution_start": datetime.utcnow().isoformat()}
            )
            
            # Execute the agent
            self.logger.debug(f"🔄 Executing {agent_name}...")
            signals = await agent.generate_signals(snapshot)
            
            # Record successful heartbeat
            await self.heartbeat_manager.heartbeat(
                agent_name=agent_name,
                status="healthy",
                metadata={
                    "signals_generated": len(signals),
                    "execution_end": datetime.utcnow().isoformat()
                }
            )
            
            self.logger.info(f"✅ {agent_name} executed successfully - generated {len(signals)} signals")
            
        except Exception as e:
            # Capture the full exception details
            error_msg = f"{type(e).__name__}: {str(e)}"
            last_error = error_msg
            status = "error"
            
            # Log the exception
            self.logger.error(f"❌ {agent_name} execution failed: {error_msg}")
            self.logger.debug(f"Full traceback:\n{traceback.format_exc()}")
            
            # Record error heartbeat
            await self.heartbeat_manager.heartbeat(
                agent_name=agent_name,
                status="error",
                last_error=last_error,
                metadata={
                    "error_type": type(e).__name__,
                    "traceback": traceback.format_exc(),
                    "execution_failed": datetime.utcnow().isoformat()
                }
            )
            
            # Don't re-raise - let the system continue with other agents
            signals = []
        
        return signals
    
    async def execute_multiple_agents(self, agents: List[BaseAgent], snapshot: Dict[str, Any]) -> Dict[str, List[Dict]]:
        """
        Execute multiple agents in parallel with heartbeat monitoring
        
        Args:
            agents: List of agents to execute
            snapshot: Market data snapshot
            
        Returns:
            Dictionary mapping agent names to their generated signals
        """
        self.logger.info(f"🚀 Executing {len(agents)} agents in parallel...")
        
        # Execute all agents in parallel
        tasks = [
            self.execute_agent_with_heartbeat(agent, snapshot)
            for agent in agents
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Organize results by agent name
        agent_results = {}
        for agent, result in zip(agents, results):
            if isinstance(result, Exception):
                self.logger.error(f"❌ Agent {agent.name} failed with exception: {result}")
                agent_results[agent.name] = []
            else:
                agent_results[agent.name] = result
        
        return agent_results


# Global heartbeat manager instance
heartbeat_manager = None

def initialize_heartbeat_system(supabase_url: Optional[str] = None, supabase_key: Optional[str] = None) -> HeartbeatManager:
    """
    Initialize the global heartbeat system
    
    Args:
        supabase_url: Supabase project URL (from env if not provided)
        supabase_key: Supabase anon key (from env if not provided)
        
    Returns:
        HeartbeatManager instance
    """
    global heartbeat_manager
    
    # Get credentials from environment if not provided
    if not supabase_url:
        supabase_url = os.getenv('SUPABASE_URL')
    if not supabase_key:
        supabase_key = os.getenv('SUPABASE_ANON_KEY')
    
    heartbeat_manager = HeartbeatManager(supabase_url, supabase_key)
    return heartbeat_manager

def get_heartbeat_manager() -> HeartbeatManager:
    """Get the global heartbeat manager instance"""
    global heartbeat_manager
    if heartbeat_manager is None:
        heartbeat_manager = initialize_heartbeat_system()
    return heartbeat_manager

# Convenience function for backward compatibility
async def heartbeat(agent_name: str, status: str = "healthy", last_error: Optional[str] = None, metadata: Optional[Dict] = None) -> bool:
    """Convenience function to record heartbeat using global manager"""
    manager = get_heartbeat_manager()
    return await manager.heartbeat(agent_name, status, last_error, metadata)