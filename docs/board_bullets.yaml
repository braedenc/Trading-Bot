# ---------- Phase 0 ----------
- id: P0.4
  phase: 0
  title: Baseline Tag v0.1-pre-agent
  design_contract:
    file: null
    steps:
      - run: git fetch origin main
      - run: git tag v0.1-pre-agent origin/main
      - run: git push --tags
      - run: git ls-remote --tags origin "v0.1-*"
    acceptance:
      - Remote tag v0.1-pre-agent exists and is visible in GitHub UI
      - Verification log pasted into PR

# ---------- Phase 1 ----------
- id: P1.2
  phase: 1
  title: GitHub Actions CI and Rubric Gates
  design_contract:
    file: .github/workflows/ci.yml
    constraints:
      - Jobs order: lint → typecheck → test (coverage.xml) → security → build → spec-enforcer
      - Coverage: lines >= 85%, branches >= 80%
      - Required checks on main: lint,typecheck,test,security,build,spec-enforcer
      - Local gate: `make ci-local` passes on clean checkout
    tests:
      - CI is green on this PR and on main
    acceptance:
      - PR includes `Card: P1.2` in body
      - coverage.xml present
      - Spec Enforcer score >= 9/10

# ---------- Phase 2 (next up) ----------
- id: P2.1.1
  parent_id: P2.1
  title: Engine core class
  design_contract:
    file: trading_bot/engine/core.py
    interface: |
      class Engine:
          async def start(self): ...
          async def stop(self): ...
          def register_agent(self, agent: "BaseStrategy"): ...
    constraints:
      - asyncio.TaskGroup for lifecycle; cancellation on stop()
      - asyncio.Queue(maxsize=10000) for ticks; export queue_depth metric
      - No global state; no sync I/O in loop
    tests:
      - Simulated 100k ticks; p95 processing latency < 2 ms
      - At least one integration test
    acceptance:
      - PR includes `Card: P2.1.1`

# ---------- Phase 2 (Data Adapters) ----------
- id: P2.2.0
  title: DataAdapter Port
  design_contract:
    file: trading_bot/data/base.py
    interface: |
      class BaseDataAdapter(Protocol):
          async def subscribe(self, symbols: Sequence[str]) -> AsyncIterator[Bar]: ...
          async def close(self) -> None: ...
    constraints:
      - No sync I/O; asyncio only
      - Strong typing (mypy --strict)
    tests:
      - Type check + import smoke test
    acceptance:
      - PR includes `Card: P2.2.0`

- id: P2.2.1
  parent_id: P2.2
  title: TwelveDataRestAdapter
  design_contract:
    file: trading_bot/data/twelvedata_rest.py
    interface: |
      class TwelveDataRestAdapter(BaseDataAdapter):
          def __init__(self, api_key: str, base_url: str = "https://api.twelvedata.com"): ...
          async def subscribe(self, symbols: Sequence[str]) -> AsyncIterator[Bar]: ...
          async def close(self) -> None: ...
    constraints:
      - Use aiohttp session reuse; no sync I/O
      - Fetch latest 1-minute bars via REST: GET /time_series?symbol=<SYM>&interval=1min&outputsize=1&apikey=****
      - Handle HTTP 429: honor Retry-After if present; else exponential backoff (0.5s * 2^n, cap 32s)
      - Structured warning log on non-200; emit audit_event(type="data_error") in real impl
    tests:
      - aioresponses: yields a Bar for a mocked response with values[0]
      - 429 path: honors Retry-After when present; otherwise backs off
      - branch coverage ≥ 95% for adapter module
    acceptance:
      - PR includes `Card: P2.2.1`

- id: P2.2.2
  parent_id: P2.2
  title: TwelveDataWsAdapter
  design_contract:
    file: trading_bot/data/twelvedata_ws.py
    interface: |
      class TwelveDataWsAdapter(BaseDataAdapter):
          def __init__(self, api_key: str, ws_url: str = "wss://ws.twelvedata.com/v1/stream"): ...
          async def subscribe(self, symbols: Sequence[str]) -> AsyncIterator[Bar]: ...
          async def close(self) -> None: ...
    constraints:
      - No sync I/O; use aiohttp.ws_connect or injected feed for tests
      - Reconnect with exponential backoff on network errors (cap 32s)
      - Map vendor message to Bar (Decimal prices; int volume)
      - Keep CPU idle when idle (await, no busy loops)
    tests:
      - Injected fake feed yields a Bar and adapter forwards it
      - Reconnect/backoff path covered by raising once then recovering
      - mypy --strict clean
    acceptance:
      - PR includes `Card: P2.2.2`

- id: P2.4.1
  parent_id: P2.4
  title: RiskGuard middleware
  design_contract:
    file: trading_bot/risk/guards.py
    interface: |
      class RiskGuard:
          def check(self, order: OrderCtx) -> None  # raises RiskError
    constraints:
      - Use Decimal/integer minor units; no float money
      - Max notional via env MAX_NOTIONAL; price band ±3×ATR(14)
    tests:
      - Parametrized: pass, notional breach, price-band breach
      - Property-based: random orders never bypass rules
    acceptance:
      - PR includes `Card: P2.4.1`